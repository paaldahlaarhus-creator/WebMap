## Oslofjord – Økologisk tilstand
<!--Denne Html delen bygger strukturen på dashboarder  -->
Velg først målingstype, så tidsperiode:

<div id="measure-controls" style="margin-bottom: 0.5rem;">
  <strong>Målingstype:</strong> <!-- strong uthever teksten -->
  <button type="button" class="measure-btn" data-measure="avg"  onclick="setMeasure('avg')">Gjennomsnittsmåling</button><!-- Denne koden legger til knappen, classifiserer den tildeler den datasett -->
  <button type="button" class="measure-btn" data-measure="low"  onclick="setMeasure('low')">Laveste måling</button>
  <button type="button" class="measure-btn" data-measure="high" onclick="setMeasure('high')">Høyeste måling</button>
</div>

<div id="period-controls" style="margin-bottom: 0.5rem;">
  <strong>Periode:</strong> <!-- gjør akkurat det samme som over bare for periode knappene --> 
  <button type="button" class="period-btn" data-period="p2023"       onclick="setPeriod('p2023')">2023</button>
  <button type="button" class="period-btn" data-period="p2020_2022"  onclick="setPeriod('p2020_2022')">2020–2022</button>
  <button type="button" class="period-btn" data-period="p2019_2015"  onclick="setPeriod('p2019_2015')">2015–2019</button>
</div>

<div id="current-selection" style="margin-bottom: 1rem; font-weight: bold;">
  <!-- Her fylles tekst inn av JavaScript -->
</div>

<style>
  #measure-controls button,
  #period-controls button {
    margin-left: 0.25rem;
    margin-right: 0.25rem;
    padding: 0.25rem 0.6rem;
    border-radius: 4px;
    border: 1px solid #ccc;
    background-color: #f5f5f5;
    cursor: pointer;
  }

  #measure-controls button.active,<!-- marker knappen blå når den er aktiv --> 
  #period-controls button.active {
    background-color: #2c7fb8;
    color: white;
    border-color: #2c7fb8;
  }
</style>

<script>
  let currentMeasure = 'avg';
  let currentPeriod  = 'p2023';

  const allMapIds = [
    'map_avg_p2023', 'map_avg_p2020_2022', 'map_avg_p2019_2015',
    'map_low_p2023', 'map_low_p2020_2022', 'map_low_p2019_2015',
    'map_high_p2023','map_high_p2020_2022','map_high_p2019_2015'
  ];

  const measureLabels = {
    'avg':  'Gjennomsnittsmåling',
    'low':  'Laveste måling',
    'high': 'Høyeste måling'
  };

  const periodLabels = {
    'p2023':       '2023',
    'p2020_2022':  '2020–2022',
    'p2019_2015':  '2015–2019'
  };

  function updateButtonStyles() { <!-- Disse funskjonene er JS som her brukes til og formatere nettsiden --> 
    // Målingstype-knapper
    document.querySelectorAll('#measure-controls .measure-btn').forEach(function(btn) {
      const m = btn.getAttribute('data-measure');
      if (m === currentMeasure) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active'); <!-- if aktiverer knappen så den faktisk endrer seg hvis den er trykket på, else fjerner den --> 
      }
    });

    // Periode-knapper
    document.querySelectorAll('#period-controls .period-btn').forEach(function(btn) {
      const p = btn.getAttribute('data-period');
      if (p === currentPeriod) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
  }

  function updateLabel() {
    const el = document.getElementById('current-selection');
    if (!el) return;
    const mLabel = measureLabels[currentMeasure] || '';
    const pLabel = periodLabels[currentPeriod]   || '';
    el.textContent = mLabel + ' – ' + pLabel;   <!-- koden legger til tekst over kartet som beskriver hvilket mål som er brukt og i hvilken periode --> 
  }

  function updateVisibleMap() {
    const targetId = 'map_' + currentMeasure + '_' + currentPeriod;
    allMapIds.forEach(function(id) {
      const el = document.getElementById(id);
      if (!el) return;
      el.style.display = (id === targetId) ? 'block' : 'none';
    }); <!-- oppdaterer det kartet som er synlig --> 
    updateButtonStyles();
    updateLabel();
  }

  function setMeasure(m) {
    currentMeasure = m;
    updateVisibleMap();
  }

  function setPeriod(p) {
    currentPeriod = p;
    updateVisibleMap();
  }

  document.addEventListener("DOMContentLoaded", function() {
    updateVisibleMap(); // vis gjennomsnitt 2023 som default og sett aktive knapper + label
  });
</script>


```{r}
library(here)
library(qs)
library(sf)
library(leaflet)
library(htmltools)
library(dplyr)
library(stringr)

#---------------------------
# 1. Hjelper: les kart
#---------------------------
read_map <- function(qs_path, geojson_path) {
  if (file.exists(qs_path)) {
    tryCatch(
      qs::qread(qs_path),
      error = function(e) {
        message("Kunne ikke lese .qs, bruker GeoJSON i stedet.")
        sf::st_read(geojson_path, quiet = TRUE)
      }
    )
  } else {
    sf::st_read(geojson_path, quiet = TRUE)
  }
}

# Standardiser kommunenavn: trim + lower-case
clean_name <- function(x) {
  x |>
    as.character() |>
    trimws() |>
    str_to_lower()
}

#---------------------------
# 2. Last inn kommunekart
#---------------------------
komm_qs  <- here("data", "kommuner.qs")
komm_geo <- here("www", "assets", "kommuner.geojson")
kommuner <- read_map(komm_qs, komm_geo)

if (is.na(sf::st_crs(kommuner))) sf::st_crs(kommuner) <- 4258
kommuner <- sf::st_transform(kommuner, 4326)

lab_komm <- "kommunenavn"
if (!lab_komm %in% names(kommuner)) {
  stop("Fant ikke kolonnen 'kommunenavn' i kartdata. Kolonner er: ",
       paste(names(kommuner), collapse = ", "))
}

# Lag nøkkel for matching i kartdata
kommuner <- kommuner |>
  mutate(name_key = clean_name(kommunenavn))

# Oslofjord-kommuner (logiske navn)
oslofjord_names <- c(
  "Oslo","Bærum","Asker","Nesodden","Frogn","Ås","Vestby","Moss",
  "Fredrikstad","Hvaler","Tønsberg","Horten","Larvik","Sandefjord",
  "Færder","Holmestrand","Råde","Drammen","Nordre Follo", 
  "Porsgrunn", "Bamble", "Kragerø", "Sarpsborg", "Halden"
)

oslofjord_keys <- clean_name(oslofjord_names)

of_komm <- kommuner |>
  filter(name_key %in% oslofjord_keys)

#---------------------------
# 3. Les eco_2023_merged
#---------------------------
eco_path <- here("data", "eco_2023_merged.qs")
if (!file.exists(eco_path)) {
  stop("Finner ikke fila: ", eco_path)
}
eco_2023 <- qs::qread(eco_path)

stopifnot(all(c("Kommune","Kvalitetselement","År","nEQR","Tilstand_element") %in% names(eco_2023)))

# Nøkkel i eco-data (inkl. fiks for PROSGRUNN -> Porsgrunn)
eco_2023 <- eco_2023 |>
  mutate(
    Kommune_key = clean_name(Kommune),
    Kommune_key = if_else(Kommune_key == "prosgrunn", "porsgrunn", Kommune_key)
  ) |>
  # bare Oslofjord-kommunene
  filter(Kommune_key %in% oslofjord_keys)

# Hent alle unike kvalitetselementer som faktisk finnes for Oslofjord-kommunene
ke_levels <- sort(unique(eco_2023$Kvalitetselement))

#---------------------------
# 4. Fargefunksjon for Tilstand_element
#---------------------------
tilstand_color <- function(x) {
  case_when(
    x == "SVÆRT GOD"    ~ "#08306b",  # mørk blå
    x == "GOD"          ~ "#41ab5d",  # lys grønn
    x == "MODERAT"      ~ "#ffffb2",  # gul
    x == "DÅRLIG"       ~ "#fe9929",  # oransje
    x == "SVÆRT DÅRLIG" ~ "#de2d26",  # rød
    TRUE                ~ "#cccccc"   # grå: ingen data
  )
}

#---------------------------
# 5. Lag ett kart-lag per Kvalitetselement
#   - En kommune er FARGET i et lag kun hvis den har data for det elementet
#   - Fargen bestemmes av Tilstand_element
#---------------------------
ke_maps <- list()

for (ke in ke_levels) {
  eco_ke <- eco_2023 |>
    filter(Kvalitetselement == ke) |>
    group_by(Kommune_key, Kommune, Kvalitetselement) |>
    summarise(
      nEQR            = mean(nEQR, na.rm = TRUE),
      Tilstand_element = first(na.omit(Tilstand_element), default = NA_character_),
      .groups = "drop"
    )
  
  of_komm_ke <- of_komm |>
    left_join(
      eco_ke,
      by = c("name_key" = "Kommune_key")
    )
  
  ke_maps[[ke]] <- of_komm_ke
}

#---------------------------
# 6. Bygg leaflet-kart
#   - Ett overlay-lag per Kvalitetselement
#   - Kommuner uten data for valgt element blir grå (NA -> grå i tilstand_color)
#---------------------------
m <- leaflet(options = leafletOptions(zoomControl = TRUE)) |>
  addProviderTiles(providers$CartoDB.Positron)

m <- leaflet(options = leafletOptions(zoomControl = TRUE)) |>
  addProviderTiles(providers$CartoDB.Positron)

for (ke in ke_levels) {
  ke_label <- ke
  
  # ta ut data for dette elementet og lag én popup-tekst per rad
  ke_data <- ke_maps[[ke]] |>
    mutate(
      popup_text = paste0(
        "<b>", kommunenavn, "</b><br>",
        "Kvalitetselement: ", ke_label, "<br>",
        "Tilstand: ",
        ifelse(is.na(Tilstand_element), "Ingen data", Tilstand_element), "<br>",
        "nEQR: ",
        ifelse(is.na(nEQR), "–", sprintf("%.3f", nEQR))
      )
    )
  
  m <- m |>
    addPolygons(
      data        = ke_data,
      group       = ke,           # brukes i filter-menyen
      color       = "#444444",
      weight      = 1,
      fillOpacity = 0.7,
      fillColor   = ~ tilstand_color(Tilstand_element),
      # ÉN label per rad – ikke én stor streng
      label       = ~ lapply(popup_text, htmltools::HTML)
      # evt. bruk popup i stedet:
      # popup      = ~ lapply(popup_text, htmltools::HTML)
    )
}

m |>
  addLayersControl(
    baseGroups    = c("Kvalitetselementer"),
    overlayGroups = ke_levels,
    options       = layersControlOptions(collapsed = FALSE)
  ) |>
  setView(lng = 10.5, lat = 59.2, zoom = 8)




```

